/**
 * Generated by orval v6.28.2 üç∫
 * Do not edit manually.
 * Taxopark API
 * Taxopark is a company that transports passengers between cities
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  DeleteLocationLocationDeleteDeleteParams,
  HTTPValidationError,
  LocationInput,
  LocationOutput
} from '.././model'
import { createInstance } from '.././http/index';
import type { BodyType } from '.././http/index';


type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * Create new location
 * @summary Create Location
 */
export const createLocationLocationNewPost = (
    locationInput: BodyType<LocationInput>,
 options?: SecondParameter<typeof createInstance>,) => {
      
      
      return createInstance<LocationOutput>(
      {url: `/location/new`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: locationInput
    },
      options);
    }
  


export const getCreateLocationLocationNewPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLocationLocationNewPost>>, TError,{data: BodyType<LocationInput>}, TContext>, request?: SecondParameter<typeof createInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createLocationLocationNewPost>>, TError,{data: BodyType<LocationInput>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createLocationLocationNewPost>>, {data: BodyType<LocationInput>}> = (props) => {
          const {data} = props ?? {};

          return  createLocationLocationNewPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateLocationLocationNewPostMutationResult = NonNullable<Awaited<ReturnType<typeof createLocationLocationNewPost>>>
    export type CreateLocationLocationNewPostMutationBody = BodyType<LocationInput>
    export type CreateLocationLocationNewPostMutationError = HTTPValidationError

    /**
 * @summary Create Location
 */
export const useCreateLocationLocationNewPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLocationLocationNewPost>>, TError,{data: BodyType<LocationInput>}, TContext>, request?: SecondParameter<typeof createInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createLocationLocationNewPost>>,
        TError,
        {data: BodyType<LocationInput>},
        TContext
      > => {

      const mutationOptions = getCreateLocationLocationNewPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Delete location by ID
 * @summary Delete Location
 */
export const deleteLocationLocationDeleteDelete = (
    params: DeleteLocationLocationDeleteDeleteParams,
 options?: SecondParameter<typeof createInstance>,) => {
      
      
      return createInstance<unknown>(
      {url: `/location/delete`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteLocationLocationDeleteDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteLocationLocationDeleteDelete>>, TError,{params: DeleteLocationLocationDeleteDeleteParams}, TContext>, request?: SecondParameter<typeof createInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteLocationLocationDeleteDelete>>, TError,{params: DeleteLocationLocationDeleteDeleteParams}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteLocationLocationDeleteDelete>>, {params: DeleteLocationLocationDeleteDeleteParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteLocationLocationDeleteDelete(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteLocationLocationDeleteDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteLocationLocationDeleteDelete>>>
    
    export type DeleteLocationLocationDeleteDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Location
 */
export const useDeleteLocationLocationDeleteDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteLocationLocationDeleteDelete>>, TError,{params: DeleteLocationLocationDeleteDeleteParams}, TContext>, request?: SecondParameter<typeof createInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteLocationLocationDeleteDelete>>,
        TError,
        {params: DeleteLocationLocationDeleteDeleteParams},
        TContext
      > => {

      const mutationOptions = getDeleteLocationLocationDeleteDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Get all location
 * @summary Get Locations
 */
export const getLocationsLocationAllGet = (
    
 options?: SecondParameter<typeof createInstance>,signal?: AbortSignal
) => {
      
      
      return createInstance<LocationOutput[]>(
      {url: `/location/all`, method: 'GET', signal
    },
      options);
    }
  

export const getGetLocationsLocationAllGetQueryKey = () => {
    return [`/location/all`] as const;
    }

    
export const getGetLocationsLocationAllGetQueryOptions = <TData = Awaited<ReturnType<typeof getLocationsLocationAllGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationsLocationAllGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLocationsLocationAllGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocationsLocationAllGet>>> = ({ signal }) => getLocationsLocationAllGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLocationsLocationAllGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLocationsLocationAllGetQueryResult = NonNullable<Awaited<ReturnType<typeof getLocationsLocationAllGet>>>
export type GetLocationsLocationAllGetQueryError = unknown

/**
 * @summary Get Locations
 */
export const useGetLocationsLocationAllGet = <TData = Awaited<ReturnType<typeof getLocationsLocationAllGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationsLocationAllGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetLocationsLocationAllGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get location by ID
 * @summary Get Location
 */
export const getLocationLocationLocationIdGet = (
    locationId: number,
 options?: SecondParameter<typeof createInstance>,signal?: AbortSignal
) => {
      
      
      return createInstance<LocationOutput>(
      {url: `/location/${locationId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetLocationLocationLocationIdGetQueryKey = (locationId: number,) => {
    return [`/location/${locationId}`] as const;
    }

    
export const getGetLocationLocationLocationIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getLocationLocationLocationIdGet>>, TError = HTTPValidationError>(locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationLocationLocationIdGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLocationLocationLocationIdGetQueryKey(locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLocationLocationLocationIdGet>>> = ({ signal }) => getLocationLocationLocationIdGet(locationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(locationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLocationLocationLocationIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLocationLocationLocationIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getLocationLocationLocationIdGet>>>
export type GetLocationLocationLocationIdGetQueryError = HTTPValidationError

/**
 * @summary Get Location
 */
export const useGetLocationLocationLocationIdGet = <TData = Awaited<ReturnType<typeof getLocationLocationLocationIdGet>>, TError = HTTPValidationError>(
 locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLocationLocationLocationIdGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetLocationLocationLocationIdGetQueryOptions(locationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get children locations by ID
 * @summary Get Children Locations
 */
export const getChildrenLocationsLocationLocationIdChildrenGet = (
    locationId: number,
 options?: SecondParameter<typeof createInstance>,signal?: AbortSignal
) => {
      
      
      return createInstance<LocationOutput[]>(
      {url: `/location/${locationId}/children`, method: 'GET', signal
    },
      options);
    }
  

export const getGetChildrenLocationsLocationLocationIdChildrenGetQueryKey = (locationId: number,) => {
    return [`/location/${locationId}/children`] as const;
    }

    
export const getGetChildrenLocationsLocationLocationIdChildrenGetQueryOptions = <TData = Awaited<ReturnType<typeof getChildrenLocationsLocationLocationIdChildrenGet>>, TError = HTTPValidationError>(locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildrenLocationsLocationLocationIdChildrenGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChildrenLocationsLocationLocationIdChildrenGetQueryKey(locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChildrenLocationsLocationLocationIdChildrenGet>>> = ({ signal }) => getChildrenLocationsLocationLocationIdChildrenGet(locationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(locationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChildrenLocationsLocationLocationIdChildrenGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetChildrenLocationsLocationLocationIdChildrenGetQueryResult = NonNullable<Awaited<ReturnType<typeof getChildrenLocationsLocationLocationIdChildrenGet>>>
export type GetChildrenLocationsLocationLocationIdChildrenGetQueryError = HTTPValidationError

/**
 * @summary Get Children Locations
 */
export const useGetChildrenLocationsLocationLocationIdChildrenGet = <TData = Awaited<ReturnType<typeof getChildrenLocationsLocationLocationIdChildrenGet>>, TError = HTTPValidationError>(
 locationId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildrenLocationsLocationLocationIdChildrenGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetChildrenLocationsLocationLocationIdChildrenGetQueryOptions(locationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



